<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Generative Movie Poster AI - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Lato:wght@300;400;700&family=Montserrat:wght@400;700;900&family=Oswald:wght@400;700&family=Poppins:wght@400;600;700&family=Orbitron:wght@700;900&family=Cinzel:wght@600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
        }
        
        .font-oswald { font-family: 'Oswald', sans-serif; }
        .font-bebas { font-family: 'Bebas Neue', sans-serif; }
        .font-montserrat { font-family: 'Montserrat', sans-serif; }
        .font-poppins { font-family: 'Poppins', sans-serif; }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .font-cinzel { font-family: 'Cinzel', sans-serif; }

        .glass-morphism {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .neon-glow {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        
        .poster-glow {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }
        
        .floating {
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .fade-in {
            animation: fadeIn 0.8s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .pulse-ring {
            animation: pulseRing 2s infinite;
        }
        
        @keyframes pulseRing {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        .gradient-text {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.6);
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .floating {
                animation: none;
            }
            
            .glass-morphism {
                backdrop-filter: blur(5px);
            }
            
            button {
                min-height: 44px;
                min-width: 44px;
            }
            
            input, select, textarea {
                font-size: 16px;
            }
        }
		
		@media (min-width: 769px) {
			#poster-container {
				aspect-ratio: 4 / 5 !important; /* Match your canvas ratio exactly */
			}
			
			#poster-image {
				width: 100% !important;
				height: 100% !important;
				object-fit: contain !important;
				object-position: center !important;
			}
		}
        
        canvas {
            will-change: contents;
        }
    </style>
</head>
<body class="text-gray-200 flex flex-col items-center justify-center min-h-screen p-4 sm:p-6 lg:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-12 fade-in">
            <h1 class="text-5xl sm:text-7xl font-bebas tracking-wider gradient-text mb-4">
                Generative Movie Poster AI
            </h1>
            <p class="text-xl text-gray-400 mb-2">Powered by Advanced AI â€¢ Creating Cinematic Art</p>
            <div class="flex justify-center items-center space-x-4 text-sm text-gray-500">
                <span id="status-indicator" class="flex items-center">
                    <div class="w-2 h-2 bg-green-500 rounded-full mr-2 pulse-ring"></div>
                    <span>Ready</span>
                </span>
                <span>â€¢</span>
                <span id="generation-counter">0 posters created</span>
                <span>â€¢</span>
                <span id="auto-timer">Next: Auto</span>
            </div>
        </header>

        <main class="grid grid-cols-1 xl:grid-cols-4 gap-8">
            <div class="xl:col-span-3 glass-morphism p-6 rounded-2xl shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-montserrat font-bold text-white">Current Generation</h2>
                    <div class="flex space-x-2">
                        <button id="save-btn" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Save Poster
                        </button>
                        <button id="share-btn" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Share
                        </button>
                    </div>
                </div>
                
                <div id="poster-container" class="w-full max-w-lg mx-auto aspect-[2/3] rounded-xl overflow-hidden poster-glow floating relative">
                    <div id="loader" class="absolute inset-0 bg-gray-800 flex items-center justify-center z-10">
                        <div class="text-center">
                            <svg aria-hidden="true" class="w-16 h-16 text-gray-400 animate-spin fill-blue-600 mx-auto mb-4" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C9.08144 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"/>
                                <path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0492C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"/>
                            </svg>
                            <p id="loading-text" class="text-lg font-medium text-blue-400">Generating concept...</p>
                            <div class="w-64 bg-gray-700 rounded-full h-2 mt-4">
                                <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    <img id="poster-image" src="" alt="Generated Movie Poster" class="hidden w-full h-full object-cover">
                </div>
            </div>

            <div class="xl:col-span-1 space-y-6">
                <div class="glass-morphism p-6 rounded-2xl">
                    <h3 class="text-xl font-montserrat font-bold text-white mb-4">Controls</h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                          <label class="text-sm font-medium text-gray-300">Hardcore Mode</label>
                          <button id="nod-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-600 transition-colors">
                            <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                          </button>
                        </div>
                        <button id="generate-btn" class="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-bold py-4 px-6 rounded-xl shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none neon-glow">
                            <span id="btn-text">Generate New Poster</span>
                        </button>
                        
                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-300">Auto-generate</label>
                            <button id="auto-toggle" class="relative inline-flex h-6 w-11 items-center rounded-full bg-gray-600 transition-colors">
                                <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"></span>
                            </button>
                        </div>
                        
                        <div>
                            <label class="text-sm font-medium text-gray-300 block mb-2">Genre Filter</label>
                            <select id="genre-filter" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                                <option value="any">Any Genre</option>
                                <option value="horror">Horror</option>
                                <option value="sci-fi">Sci-Fi</option>
                                <option value="fusion">Sci-Fi Horror</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="text-sm font-medium text-gray-300 block mb-2">Era Preference</label>
                            <select id="era-filter" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                                <option value="any">Any Era</option>
                                <option value="1950s">1950s</option>
                                <option value="1960s">1960s</option>
                                <option value="1970s">1970s</option>
                                <option value="1980s">1980s</option>
                                <option value="1990s">1990s</option>
                                <option value="2000s">2000s</option>
                                <option value="2010s">2010s</option>
                                <option value="2020s">2020s</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="text-sm font-medium text-gray-300 block mb-2">Art Style</label>
                            <select id="art-style-filter" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                                <option value="authentic">Era Authentic</option>
                                <option value="b-movie">B-Movie Exaggerated</option>
                                <option value="photo">Modern Photography</option>
                                <option value="painted">Classic Painted Art</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="glass-morphism p-6 rounded-2xl custom-scrollbar max-h-96 overflow-y-auto">
                    <h3 class="text-xl font-montserrat font-bold text-white mb-4">Movie Details</h3>
                    <div id="movie-info" class="space-y-4">
                        <div class="border-l-4 border-blue-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Era</label>
                            <p id="decade-text" class="text-lg text-white font-medium">-</p>
                        </div>
                        <div class="border-l-4 border-purple-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Genre</label>
                            <p id="genre-text" class="text-lg text-white font-medium">-</p>
                        </div>
                        <div class="border-l-4 border-yellow-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Title</label>
                            <p id="title-text" class="text-2xl font-bebas text-yellow-400 leading-tight">-</p>
                        </div>
                        <div class="border-l-4 border-green-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Tagline</label>
                            <p id="tagline-text" class="text-base italic text-gray-300">-</p>
                        </div>
                        <div class="border-l-4 border-red-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Synopsis</label>
                            <p id="synopsis-text" class="text-sm text-gray-200 leading-relaxed">-</p>
                        </div>
                        <div class="border-l-4 border-pink-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Instagram Caption</label>
                            <div class="bg-gray-800 p-3 rounded-lg mt-2">
                                <textarea id="instagram-caption" class="w-full bg-transparent text-xs text-gray-300 resize-none border-none outline-none" rows="6" readonly placeholder="Generate a poster to see Instagram caption..."></textarea>
                                <button id="copy-caption-btn" class="mt-2 px-3 py-1 bg-pink-600 hover:bg-pink-700 rounded text-xs transition-all disabled:opacity-50" disabled>
                                    Copy Caption
                                </button>
                            </div>
                        </div>
                        <div class="border-l-4 border-indigo-500 pl-4">
                            <label class="font-bold text-xs text-gray-400 uppercase tracking-wide">Soundtrack Recommendation</label>
                            <div class="bg-gray-800 p-3 rounded-lg mt-2">
                                <div class="flex items-center space-x-2 mb-2">
                                    <span class="text-lg">ðŸŽµ</span>
                                    <div>
                                        <p id="song-title" class="text-sm font-medium text-white">-</p>
                                        <p id="song-artist" class="text-xs text-gray-400">-</p>
                                    </div>
                                </div>
                                <p id="song-reason" class="text-xs text-gray-300 italic">-</p>
                                <button id="copy-song-btn" class="mt-2 px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded text-xs transition-all disabled:opacity-50" disabled>
                                    Copy Song Info
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="error-message" class="hidden bg-red-900/50 border border-red-500 text-red-300 px-4 py-3 rounded-lg mt-4">
                        <p><strong>Error:</strong> <span id="error-text"></span></p>
                        <button id="retry-btn" class="mt-2 px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-sm">Retry</button>
                    </div>
                </div>

                <div class="glass-morphism p-6 rounded-2xl">
                    <h3 class="text-xl font-montserrat font-bold text-white mb-4">Recent Generations</h3>
                    <div id="recent-posters" class="grid grid-cols-2 gap-2">
                    </div>
                </div>
            </div>
        </main>
    </div>

    <canvas id="poster-canvas" class="hidden"></canvas>

    <script>
        // Normalize any image string into a safe URL for <img>.src (prevents blockers and canvas taint)
        function normalizeToBlobUrl(maybeBase64OrUrl) {
            try {
                let s = String(maybeBase64OrUrl || '');

                // Already safe?
                if (s.startsWith('blob:') || s.startsWith('data:')) return s;

                // Raw base64 without prefix? Wrap it
                if (!/^https?:\/\//i.test(s) && !s.startsWith('data:')) {
                    s = 'data:image/png;base64,' + s;
                }

                // If still http(s), leave it (server handles CORS/base64); otherwise convert data: â†’ blob:
                if (!s.startsWith('data:')) return s;

                const comma = s.indexOf(',');
                const header = s.slice(0, comma);
                const b64 = s.slice(comma + 1);
                const mimeMatch = /data:(.*?);base64/i.exec(header);
                const mime = (mimeMatch && mimeMatch[1]) || 'image/png';

                const bin = atob(b64);
                const bytes = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

                return URL.createObjectURL(new Blob([bytes], { type: mime }));
            } catch (e) {
                console.warn('normalizeToBlobUrl failed:', e);
                return maybeBase64OrUrl;
            }
        }

        class EnhancedPosterAI {
            constructor() {
                console.log('EnhancedPosterAI constructor called');
                
                this.BACKEND_BASE_URL = window.location.origin.includes('localhost') || window.location.origin.includes('127.0.0.1') 
                    ? 'http://localhost:3000' 
                    : window.location.origin;
                this.CONCEPT_API_URL = this.BACKEND_BASE_URL + '/api/generate-concept';
                this.IMAGE_API_URL = this.BACKEND_BASE_URL + '/api/generate-image';
                
                this.isGenerating = false;
                this.autoGenerate = false;
                this.generationCount = 0;
                this.autoTimer = null;
                this.recentPosters = [];
                this.currentConcept = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupCanvas();
                this.checkBackendHealth();
            }

            initializeElements() {
                console.log('Initializing DOM elements...');
                this.elements = {
                    generateBtn: document.getElementById('generate-btn'),
                    posterImage: document.getElementById('poster-image'),
                    loader: document.getElementById('loader'),
                    loadingText: document.getElementById('loading-text'),
                    progressBar: document.getElementById('progress-bar'),
                    btnText: document.getElementById('btn-text'),
                    
                    decadeText: document.getElementById('decade-text'),
                    genreText: document.getElementById('genre-text'),
                    titleText: document.getElementById('title-text'),
                    taglineText: document.getElementById('tagline-text'),
                    synopsisText: document.getElementById('synopsis-text'),
                    instagramCaption: document.getElementById('instagram-caption'),
                    copyCaptionBtn: document.getElementById('copy-caption-btn'),
                    songTitle: document.getElementById('song-title'),
                    songArtist: document.getElementById('song-artist'),
                    songReason: document.getElementById('song-reason'),
                    copySongBtn: document.getElementById('copy-song-btn'),
                    
                    autoToggle: document.getElementById('auto-toggle'),
                    nodToggle: document.getElementById('nod-toggle'),
                    genreFilter: document.getElementById('genre-filter'),
                    eraFilter: document.getElementById('era-filter'),
                    artStyleFilter: document.getElementById('art-style-filter'),
                    saveBtn: document.getElementById('save-btn'),
                    shareBtn: document.getElementById('share-btn'),
                    
                    statusIndicator: document.getElementById('status-indicator'),
                    generationCounter: document.getElementById('generation-counter'),
                    autoTimer: document.getElementById('auto-timer'),
                    
                    errorMessage: document.getElementById('error-message'),
                    errorText: document.getElementById('error-text'),
                    retryBtn: document.getElementById('retry-btn'),
                    
                    recentPosters: document.getElementById('recent-posters'),
                    canvas: document.getElementById('poster-canvas')
                };
                
                this.nodTheme = false;
                console.log('DOM elements initialized');
            }

            setupCanvas() {
                const canvas = this.elements.canvas;
                this.ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = 1024;
                canvas.height = 1280; // 4:5 ratio for Instagram
                
                // Enable high-quality rendering
                this.ctx.imageSmoothingEnabled = true;
                if (this.ctx.imageSmoothingQuality) {
                    this.ctx.imageSmoothingQuality = 'high';
                }
                
                console.log('Canvas initialized:', canvas.width, 'x', canvas.height);
            }

            setupEventListeners() {
                const self = this;
                console.log('Setting up event listeners...');
                
                this.elements.generateBtn.addEventListener('click', function() { self.handleGenerationSafely(); });
                this.elements.autoToggle.addEventListener('click', function() { self.toggleAutoGenerate(); });
                this.elements.saveBtn.addEventListener('click', function() { self.savePoster(); });
                this.elements.shareBtn.addEventListener('click', function() { self.sharePoster(); });
                this.elements.retryBtn.addEventListener('click', function() { self.handleGeneration(); });
                this.elements.copyCaptionBtn.addEventListener('click', function() { self.copyInstagramCaption(); });
                this.elements.copySongBtn.addEventListener('click', function() { self.copySongInfo(); });
                
                if (this.elements.nodToggle) {
                    this.elements.nodToggle.addEventListener('click', () => {
                        this.nodTheme = !this.nodTheme;
                        const knob = this.elements.nodToggle.querySelector('span');
                        this.elements.nodToggle.classList.toggle('bg-red-600', this.nodTheme); // Changed to red for hardcore
                        knob.style.transform = this.nodTheme ? 'translateX(1.25rem)' : 'translateX(0.25rem)';
                    });
                }
                
                console.log('Event listeners set up');
            }

            async handleGenerationSafely() {
                if (this.isGenerating) {
                    console.log('Generation already in progress, ignoring request');
                    return;
                }
                
                setTimeout(() => {
                    this.handleGeneration();
                }, 100);
            }

            async checkBackendHealth() {
                try {
                    console.log('Checking backend health...');
                    const response = await fetch(this.BACKEND_BASE_URL + '/api/health');
                    
                    if (response.ok) {
                        const health = await response.json();
                        console.log('Backend is healthy:', health);
                        this.updateStatus('ready', 'Backend Connected');
                    } else {
                        throw new Error('Backend health check failed: ' + response.status);
                    }
                } catch (error) {
                    console.error('Backend health check failed:', error);
                    
                    const isMobile = window.innerWidth <= 768;
                    const errorMsg = isMobile 
                        ? 'Connection failed. Please check your internet connection and try again.'
                        : 'Backend server not running. Please start the server and refresh.';
                    
                    this.showError(errorMsg);
                    this.updateStatus('error', 'Backend Offline');
                }
            }

            updateProgress(stage, percentage) {
                const stages = {
                    'concept': 'Generating concept...',
                    'image': 'Creating artwork...',
                    'text': 'Composing poster...',
                    'hardcore': 'Applying hardcore elements...',
                    'complete': 'Complete!'
                };
                
                if (this.elements.loadingText) {
                    this.elements.loadingText.textContent = stages[stage] || 'Processing...';
                }
                if (this.elements.progressBar) {
                    this.elements.progressBar.style.width = percentage + '%';
                }
            }

            async generateMovieConcept() {
                console.log("Generating movie concept...");
                this.updateProgress('concept', 10);
                
                const payload = {
                    genreFilter: this.elements.genreFilter.value,
                    eraFilter: this.elements.eraFilter.value,
                    nodTheme: this.nodTheme,
                    preventText: true
                };

                try {
                    const response = await fetch(this.CONCEPT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const responseText = await response.text();

                    if (!response.ok) {
                        throw new Error('Request failed with status ' + response.status + ': ' + responseText);
                    }

                    const result = JSON.parse(responseText);
                    
                    if (result.success && result.concept) {
                        console.log("âœ… Concept generated:", result.concept);
                        this.updateProgress('concept', 30);
                        return result.concept;
                    } else {
                        throw new Error(result.error || "Invalid response from backend");
                    }
                } catch (error) {
                    console.error("Error generating concept:", error);
                    this.showError('Failed to generate concept: ' + error.message);
                    return null;
                }
            }

            async generateImage(visualElements, concept) {
                console.log("Generating image...");
                this.updateProgress('image', 50);
                
                const payload = {
                    visualElements: visualElements,
                    concept: concept
                };

                try {
                    const response = await fetch(this.IMAGE_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const responseText = await response.text();

                    if (!response.ok) {
                        throw new Error('Request failed with status ' + response.status + ': ' + responseText);
                    }

                    const result = JSON.parse(responseText);
                    
                    if (result.success && result.imageUrl) {
                        console.log("âœ… Image generated successfully");
                        this.updateProgress('image', 70);
                        return result.imageUrl;
                    } else {
                        throw new Error(result.error || "Invalid response from backend");
                    }
                } catch (error) {
                    console.error("Error generating image:", error);
                    this.showError('Failed to generate image: ' + error.message);
                    return null;
                }
            }

            buildVisualIntent(concept) {
                const genrePref = this.elements.genreFilter?.value || 'any';
                const eraPref = this.elements.eraFilter?.value || concept.decade || 'any';
                const artStyle = this.elements.artStyleFilter?.value || 'authentic';
                
                // Enhanced text prevention prompts
                const textPreventionPrompts = [
                    'image ready for custom overlay'
                ];
                
                // Hardcore mode modifications
                let hardcoreElements = '';
                if (concept.nod_theme) {
                    const genreLower = (concept.genre || '').toLowerCase();
                    if (genreLower.includes('horror')) {
                        hardcoreElements = 'intense atmospheric horror, dark psychological themes, gothic imagery, ominous shadows, spine-chilling mood, haunting visuals, macabre atmosphere (PG-13 appropriate), unsettling but tasteful horror elements';
                    } else if (genreLower.includes('sci-fi')) {
                        hardcoreElements = 'dystopian cyberpunk aesthetic, dark futuristic technology, industrial sci-fi elements, brutal alien environments, harsh technological landscapes, gritty space horror vibes, menacing robotic forms (PG-13 appropriate)';
                    } else {
                        // Default hardcore mode for other genres
                        hardcoreElements = 'intense dramatic atmosphere, dark cinematic mood, harsh lighting contrasts, gritty realism, edgy visual style (PG-13 appropriate)';
                    }
                }
                
                const professionalSpecs = [
                    `Professional cinematic illustration`,
                    `Genre: ${concept.genre || 'cinematic thriller'}`,
                    `Era: ${concept.decade || 'modern'} authentic visual style`,
                    `Visual story: ${concept.synopsis || 'compelling narrative'}`,
                    hardcoreElements, // Add hardcore elements here
                    'High-end movie concept artwork composition',
                    'Portrait orientation, cinematic framing',
                    'Professional studio lighting setup',
                    'Rich color palette with strong visual contrast',
                    ...textPreventionPrompts,
                    'Premium cinematic illustration, artwork reference only (no text).',
                    'PG-13 rating appropriate content',
                    'Professional visual presentation'
                ].filter(Boolean); // Remove any empty strings

                const finalPrompt = professionalSpecs.filter(Boolean).join('. ') + 
                    '. CRITICAL: This is concept art.';
                    
                console.log('ðŸš« Enhanced text prevention prompt generated');
                return finalPrompt;
            }

            async loadImageToCanvas(imageUrl) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            const canvas = this.elements.canvas;
                            const ctx = this.ctx;
                            
                            console.log('ðŸ“ Canvas dimensions:', canvas.width, 'x', canvas.height);
                            console.log('ðŸ“ Image dimensions:', img.width, 'x', img.height);
                            
                            // Clear canvas
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Fill with black background
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Calculate scaling to fit image in canvas while maintaining aspect ratio
                            const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            
                            // Center the image
                            const x = (canvas.width - scaledWidth) / 2;
                            const y = (canvas.height - scaledHeight) / 2;
                            
                            console.log('ðŸ“ Scaled image:', scaledWidth, 'x', scaledHeight, 'at', x, ',', y);
                            
                            // Draw image to canvas
                            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                            
                            console.log('âœ… Image loaded to canvas successfully');
                            resolve();
                            
                        } catch (error) {
                            console.error('âŒ Error drawing image to canvas:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('âŒ Error loading image:', error);
                        reject(new Error('Failed to load image'));
                    };
                    
                    // Use normalized URL to avoid CORS issues
                    img.src = normalizeToBlobUrl(imageUrl);
                });
            }

            addGradientOverlays() {
                const canvas = this.elements.canvas;
                const ctx = this.ctx;
                const w = canvas.width;
                const h = canvas.height;

                // Top gradient for title area
                const topGradient = ctx.createLinearGradient(0, 0, 0, h * 0.25);
                topGradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
                topGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
                topGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = topGradient;
                ctx.fillRect(0, 0, w, h * 0.25);

                // Bottom gradient for credits area
                const bottomGradient = ctx.createLinearGradient(0, h, 0, h * 0.75);
                bottomGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                bottomGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.4)');
                bottomGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = bottomGradient;
                ctx.fillRect(0, h * 0.75, w, h * 0.25);
                
                console.log('âœ… Gradient overlays added');
            }

            renderTitleAndCredits(concept) {
                const canvas = this.elements.canvas;
                const ctx = this.ctx;
                const w = canvas.width;
                const h = canvas.height;

                // Get era-specific styling
                const styling = this.getEraSpecificStyling(concept.decade, concept.genre);

                // Render title section
                this.renderProfessionalTitle(ctx, concept, w, h, styling);
                
                // Render complete credits section
                this.renderProfessionalCredits(ctx, concept, w, h, styling);
                
                console.log('âœ… Title and credits rendered');
            }

            getEraSpecificStyling(decade, genre) {
                const isSciFi = (genre || '').toLowerCase().includes('sci-fi');
                const isHorror = (genre || '').toLowerCase().includes('horror');
                
                const eraStyles = {
                    '1950s': {
                        titleFont: 'serif, "Times New Roman", Georgia',
                        letterSpacing: 0.05,
                        titleColor: isHorror ? '#d4af37' : '#f8f8ff',
                        titleGlow: isHorror ? 'rgba(212, 175, 55, 0.7)' : 'rgba(248, 248, 255, 0.6)',
                        glowIntensity: 8,
                        creditsFont: '"Times New Roman", Georgia, serif',
                        titleWeight: '700'
                    },
                    '1960s': {
                        titleFont: isSciFi ? '"Orbitron", "Courier New", monospace' : '"Bebas Neue", "Impact", sans-serif',
                        letterSpacing: isSciFi ? 0.12 : 0.08,
                        titleColor: isSciFi ? '#4dd0e1' : '#ffffff',
                        titleGlow: isSciFi ? 'rgba(77, 208, 225, 0.8)' : 'rgba(255, 255, 255, 0.8)',
                        glowIntensity: isSciFi ? 12 : 8,
                        creditsFont: '"Helvetica Neue", Arial, sans-serif',
                        titleWeight: '900'
                    },
                    '1970s': {
                        titleFont: '"Bebas Neue", "Impact", "Arial Black", sans-serif',
                        letterSpacing: 0.06,
                        titleColor: isHorror ? '#ff6b47' : '#f4a261',
                        titleGlow: isHorror ? 'rgba(255, 107, 71, 0.9)' : 'rgba(244, 162, 97, 0.8)',
                        glowIntensity: 14,
                        creditsFont: '"Arial", sans-serif',
                        titleWeight: '900'
                    },
                    '1980s': {
                        titleFont: '"Impact", "Bebas Neue", "Arial Black", sans-serif',
                        letterSpacing: isSciFi ? 0.18 : 0.12,
                        titleColor: isSciFi ? '#26c6da' : (isHorror ? '#e91e63' : '#ff7043'),
                        titleGlow: isSciFi ? 'rgba(38, 198, 218, 0.9)' : (isHorror ? 'rgba(233, 30, 99, 0.9)' : 'rgba(255, 112, 67, 0.9)'),
                        glowIntensity: 22,
                        creditsFont: '"Arial", "Helvetica", sans-serif',
                        titleWeight: '900'
                    },
                    '1990s': {
                        titleFont: '"Montserrat", "Arial", "Helvetica", sans-serif',
                        letterSpacing: 0.04,
                        titleColor: isHorror ? '#cd5c5c' : '#f5f5f5',
                        titleGlow: isHorror ? 'rgba(205, 92, 92, 0.7)' : 'rgba(245, 245, 245, 0.7)',
                        glowIntensity: 6,
                        creditsFont: '"Arial", "Helvetica", sans-serif',
                        titleWeight: '700'
                    },
                    '2000s': {
                        titleFont: '"Oswald", "Arial Narrow", "Arial", sans-serif',
                        letterSpacing: 0.06,
                        titleColor: isSciFi ? '#ff8a50' : '#ffffff',
                        titleGlow: isSciFi ? 'rgba(255, 138, 80, 0.8)' : 'rgba(255, 255, 255, 0.8)',
                        glowIntensity: 10,
                        creditsFont: '"Arial", "Helvetica", sans-serif',
                        titleWeight: '700'
                    },
                    '2010s': {
                        titleFont: '"Poppins", "Helvetica Neue", "Arial", sans-serif',
                        letterSpacing: 0.03,
                        titleColor: isSciFi ? '#64b5f6' : '#ffffff',
                        titleGlow: isSciFi ? 'rgba(100, 181, 246, 0.6)' : 'rgba(255, 255, 255, 0.7)',
                        glowIntensity: 8,
                        creditsFont: '"Helvetica Neue", "Arial", sans-serif',
                        titleWeight: '600'
                    },
                    '2020s': {
                        titleFont: '"Montserrat", "Helvetica Neue", "Arial", sans-serif',
                        letterSpacing: 0.02,
                        titleColor: isSciFi ? '#81c784' : '#ffffff',
                        titleGlow: isSciFi ? 'rgba(129, 199, 132, 0.6)' : 'rgba(0, 0, 0, 0.8)',
                        glowIntensity: 4,
                        creditsFont: '"Helvetica Neue", "Arial", sans-serif',
                        titleWeight: '500'
                    }
                };
                
                return eraStyles[decade] || eraStyles['1980s'];
            }

// Replace your renderProfessionalTitle function with this enhanced version:

			renderProfessionalTitle(ctx, concept, w, h, styling) {
				const titleText = (concept?.title || 'UNTITLED').toUpperCase();
				const tagline = concept?.tagline || '';
				
				// Calculate font sizes
				let titleSize = Math.min(Math.floor(w / 8), 120);
				const taglineSize = Math.floor(titleSize * 0.3);
				
				const titleY = h * 0.15;
				const maxTitleWidth = w * 0.9;
				
				// Title with era-specific styling
				ctx.save();
				ctx.font = `${styling.titleWeight} ${titleSize}px ${styling.titleFont}`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				
				// Auto-resize if too wide
				let titleWidth = ctx.measureText(titleText).width;
				while (titleWidth > maxTitleWidth && titleSize > 32) {
					titleSize -= 4;
					ctx.font = `${styling.titleWeight} ${titleSize}px ${styling.titleFont}`;
					titleWidth = ctx.measureText(titleText).width;
				}
				
				// Title shadow
				ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				ctx.fillText(titleText, w / 2 + 3, titleY + 3);
				
				// Title with glow
				ctx.shadowColor = styling.titleGlow;
				ctx.shadowBlur = styling.glowIntensity;
				ctx.fillStyle = styling.titleColor;
				ctx.fillText(titleText, w / 2, titleY);
				
				ctx.restore();
				
				// ENHANCED: Dynamic tagline wrapping
				if (tagline) {
					ctx.save();
					ctx.font = `400 ${taglineSize}px ${styling.creditsFont}`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					
					const taglineY = titleY + titleSize * 0.8;
					const maxTaglineWidth = w * 0.85; // Slightly narrower than title
					const lineHeight = taglineSize * 1.2;
					
					// Check if tagline needs wrapping
					const taglineWidth = ctx.measureText(tagline).width;
					
					if (taglineWidth <= maxTaglineWidth) {
						// Single line tagline
						ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
						ctx.fillText(tagline, w / 2 + 2, taglineY + 2);
						
						ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
						ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
						ctx.shadowBlur = 4;
						ctx.fillText(tagline, w / 2, taglineY);
					} else {
						// Multi-line tagline wrapping
						const words = tagline.split(' ');
						const lines = [];
						let currentLine = '';
						
						for (let i = 0; i < words.length; i++) {
							const testLine = currentLine + (currentLine ? ' ' : '') + words[i];
							const testWidth = ctx.measureText(testLine).width;
							
							if (testWidth > maxTaglineWidth && currentLine) {
								lines.push(currentLine);
								currentLine = words[i];
							} else {
								currentLine = testLine;
							}
						}
						
						if (currentLine) {
							lines.push(currentLine);
						}
						
						// Limit to 2 lines max
						if (lines.length > 2) {
							lines[1] = lines[1] + '...';
							lines.length = 2;
						}
						
						// Calculate starting Y position for centered multi-line text
						const totalHeight = lines.length * lineHeight;
						const startY = taglineY - (totalHeight / 2) + (lineHeight / 2);
						
						// Render each line
						lines.forEach((line, index) => {
							const lineY = startY + (index * lineHeight);
							
							// Shadow
							ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
							ctx.fillText(line, w / 2 + 2, lineY + 2);
							
							// Main text
							ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
							ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
							ctx.shadowBlur = 4;
							ctx.fillText(line, w / 2, lineY);
						});
					}
					
					ctx.restore();
				}
			}

            renderProfessionalCredits(ctx, concept, w, h, styling) {
                const creditZones = {
                    cast: { start: 0.68, height: 0.15 },
                    billing: { start: 0.84, height: 0.06 },
                    technical: { start: 0.91, height: 0.08 }
                };
                
                const cast = this.generateProfessionalCast(concept);
                
                this.renderCastBlock(ctx, cast, w, h, creditZones.cast, styling);
                this.renderBillingBlock(ctx, concept, w, h, creditZones.billing, styling);
                this.renderTechnicalBlock(ctx, concept, w, h, creditZones.technical, styling);
            }


			renderCastBlock(ctx, cast, w, h, zone, styling) {
				const zoneY = h * zone.start;
				const zoneHeight = h * zone.height;
				
				// Larger font size but more conservative
				let fontSize = Math.max(18, Math.floor(w / 35)); // Less aggressive than w/30
				const maxFontSize = Math.floor(w / 28);
				fontSize = Math.min(fontSize, maxFontSize);
				
				ctx.save();
				ctx.font = `600 ${fontSize}px ${styling.creditsFont}`;
				ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
				ctx.textAlign = 'center';
				
				// Professional movie poster shadow
				ctx.shadowColor = 'rgba(0, 0, 0, 0.95)';
				ctx.shadowBlur = 3;
				ctx.shadowOffsetX = 1;
				ctx.shadowOffsetY = 1;
				
				// Wider columns for larger text
				const leftX = w * 0.25;
				const rightX = w * 0.75;
				const lineHeight = fontSize * 1.7;
				
				// Safety check for zone bounds
				const maxRows = Math.floor(zoneHeight / lineHeight);
				const maxNames = maxRows * 2;
				const displayCast = cast.slice(0, Math.min(maxNames, cast.length));
				
				displayCast.forEach((actor, index) => {
					// Clean the actor name
					const cleanName = String(actor).split(' AS ')[0].trim().toUpperCase();
					const isLeft = index % 2 === 0;
					const xPos = isLeft ? leftX : rightX;
					const row = Math.floor(index / 2);
					const yPos = zoneY + (row * lineHeight);
					
					// Don't render if outside zone
					if (yPos + fontSize > zoneY + zoneHeight) {
						return;
					}
					
					// BETTER TEXT FITTING: More generous width and smarter truncation
					const maxWidth = w * 0.24; // Wider columns
					let displayName = cleanName;
					let textWidth = ctx.measureText(displayName).width;
					
					if (textWidth > maxWidth) {
						// Strategy 1: Try first name + last name only
						const words = cleanName.split(' ');
						if (words.length > 2) {
							displayName = words[0] + ' ' + words[words.length - 1];
							textWidth = ctx.measureText(displayName).width;
						}
						
						// Strategy 2: If still too long, try reducing font size for this name
						if (textWidth > maxWidth) {
							const originalFont = ctx.font;
							let reducedSize = fontSize;
							
							while (textWidth > maxWidth && reducedSize > fontSize * 0.7) {
								reducedSize -= 2;
								ctx.font = `600 ${reducedSize}px ${styling.creditsFont}`;
								textWidth = ctx.measureText(displayName).width;
							}
							
							// If we had to reduce too much, then truncate
							if (reducedSize <= fontSize * 0.7) {
								ctx.font = originalFont; // Reset to original size
								
								// Strategy 3: Careful truncation - keep at least 8 characters
								while (textWidth > maxWidth && displayName.length > 8) {
									displayName = displayName.substring(0, displayName.length - 1);
									textWidth = ctx.measureText(displayName).width;
								}
								
								// Only add ellipsis if we actually truncated significantly
								if (displayName.length < cleanName.length - 3) {
									displayName = displayName.trim() + '...';
								}
							}
						}
					}
					
					ctx.fillText(displayName, xPos, yPos);
					
					// Reset font if we changed it
					ctx.font = `600 ${fontSize}px ${styling.creditsFont}`;
				});
				
				ctx.restore();
			}
            renderBillingBlock(ctx, concept, w, h, zone, styling) {
                const zoneY = h * zone.start;
                const fontSize = Math.max(12, Math.floor(w / 60));
                
                ctx.save();
                ctx.font = `400 ${Math.floor(fontSize * 0.9)}px ${styling.creditsFont}`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                // Professional billing block like real posters
                const director = concept.director || this.generateDirector();
                const lineHeight = fontSize * 1.3;
                
                // Line 1: A [Studio] Film
                ctx.fillText('AN ABNORMAL STUDIOS FILM', w / 2, zoneY);
                
                // Line 2: Directed by
                ctx.font = `700 ${fontSize}px ${styling.creditsFont}`;
                ctx.fillText(`DIRECTED BY ${director.toUpperCase()}`, w / 2, zoneY + lineHeight);
                
                ctx.restore();
            }

            renderTechnicalBlock(ctx, concept, w, h, zone, styling) {
                const zoneY = h * zone.start;
                const fontSize = Math.max(9, Math.floor(w / 85));
                const lineHeight = fontSize * 1.4;
                
                ctx.save();
                ctx.font = `400 ${fontSize}px ${styling.creditsFont}`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 1;
                
                // Technical credits block - multiple lines like real posters
                const technicalLines = [
                    'EXECUTIVE PRODUCERS MICHAEL CHEN â€¢ SARAH WILLIAMS â€¢ DAVID MARTINEZ',
                    'MUSIC BY JAMES NEWTON HOWARD  CINEMATOGRAPHER ROGER DEAKINS',
                    'PRODUCTION DESIGNER SARAH GREENWOOD  EDITOR ACE SMITH',
                    'COSTUME DESIGNER JENNY BEAVAN  PRODUCED BY ABNORMAL STUDIOS'
                ];
                
                // Draw each line with proper spacing
                technicalLines.forEach((line, index) => {
                    const yPos = zoneY + (index * lineHeight);
                    
                    // Ensure text fits within poster width
                    let displayLine = line;
                    const maxWidth = w * 0.95;
                    
                    while (ctx.measureText(displayLine).width > maxWidth && displayLine.length > 50) {
                        const lastSpace = displayLine.lastIndexOf(' ', displayLine.length - 10);
                        if (lastSpace > 20) {
                            displayLine = displayLine.substring(0, lastSpace) + '...';
                        } else {
                            break;
                        }
                    }
                    
                    ctx.fillText(displayLine, w / 2, yPos);
                });
                
                // Copyright and rating at the bottom
                ctx.font = `400 ${Math.floor(fontSize * 0.9)}px ${styling.creditsFont}`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
                const copyrightY = zoneY + (technicalLines.length * lineHeight) + (lineHeight * 0.8);
                
                const runtimes = ['89 MIN', '95 MIN', '103 MIN', '117 MIN', '124 MIN'];
                const runtime = runtimes[Math.floor(Math.random() * runtimes.length)];
                ctx.fillText(`Â© ${new Date().getFullYear()} ABNORMAL STUDIOS  â€¢  ${runtime}  â€¢  NR`, w / 2, copyrightY);
                
                ctx.restore();
            }

            generateProfessionalCast(concept) {
                if (concept.cast && concept.cast.length) {
                    return concept.cast.slice(0, 4);
                }
                
                const professionalNames = [
                    'ELENA CROSS', 'MARCUS VALE', 'ZARA STORM', 'VINCENT KANE',
                    'LUNA THORNE', 'DANTE RIVERS', 'IRIS BLAKE', 'PHOENIX STEEL',
                    'NOVA FOX', 'ATLAS NIGHT', 'SAGE HUNTER', 'RAVEN COLE',
                    'JADE WINTERS', 'ORION BLACK', 'RUBY SHARP', 'COLE GREY'
                ];
                
                const shuffled = [...professionalNames].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, 4);
            }

            generateDirector() {
                const directors = [
                    'CAMERON WELLS', 'JORDAN CROSS', 'ALEX NOVA', 'MORGAN STEEL',
                    'RILEY STORM', 'CASEY NIGHT', 'DREW HUNTER', 'SAGE RIVERS'
                ];
                return directors[Math.floor(Math.random() * directors.length)];
            }

            cleanActorName(actor) {
                return String(actor).split(' AS ')[0].trim().toUpperCase();
            }

            updateInfo(concept) {
                if (this.elements.decadeText) this.elements.decadeText.textContent = concept.decade || '-';
                if (this.elements.genreText) this.elements.genreText.textContent = concept.genre || '-';
                if (this.elements.titleText) this.elements.titleText.textContent = concept.title || '-';
                if (this.elements.taglineText) this.elements.taglineText.textContent = concept.tagline || '-';
                if (this.elements.synopsisText) this.elements.synopsisText.textContent = concept.synopsis || '-';
                
                this.generateProfessionalInstagramCaption(concept);
                this.generateAISongRecommendation(concept);
                
                console.log('ðŸ“ Movie info updated');
            }

            generateProfessionalInstagramCaption(concept) {
                if (!concept.title) {
                    this.elements.instagramCaption.value = '';
                    this.elements.copyCaptionBtn.disabled = true;
                    return;
                }

                const emojis = {
                    'Horror': 'ðŸ‘»ðŸŽ­ðŸ’€',
                    'Sci-Fi': 'ðŸš€ðŸŒŒðŸ‘½',
                    'Fusion': 'ðŸŽ­ðŸŒŒðŸ’€'
                };

                const genreEmoji = emojis[concept.genre] || 'ðŸŽ¬';
                
                let caption = '';
                caption += `${genreEmoji} POSTER DROP: "${concept.title}" ${genreEmoji}\n\n`;
                caption += `ðŸŽ¯ ${concept.decade} ${concept.genre} ${concept.nod_theme ? 'â€¢ HARDCORE MODE' : ''}\n`;
                caption += `ðŸ’« "${concept.tagline}"\n\n`;
                
                const synopsis = concept.synopsis ? 
                    (concept.synopsis.length > 140 ? concept.synopsis.substring(0, 140) + '...' : concept.synopsis) :
                    'A cinematic journey that challenges perception and reality.';
                caption += `ðŸ“– ${synopsis}\n\n`;
                
                if (concept.cast && concept.cast.length > 0) {
                    const mainCast = concept.cast.slice(0, 3).map(actor => 
                        actor.split(' AS ')[0].trim()
                    ).join(' â€¢ ');
                    caption += `â­ Starring: ${mainCast}\n`;
                }
                
                if (concept.director) {
                    caption += `ðŸŽ¥ Directed by: ${concept.director}\n`;
                }
                
                caption += `\nðŸ¤– Generated with AI â€¢ What era should I explore next?\n\n`;
                caption += this.generateProfessionalHashtags(concept);

                this.elements.instagramCaption.value = caption;
                this.elements.copyCaptionBtn.disabled = false;
            }

            generateProfessionalHashtags(concept) {
                const baseTags = [
                    '#MoviePoster', '#AIArt', '#FilmDesign', '#CinematicArt',
                    '#GenerativeAI', '#PosterDesign', '#ArtificialIntelligence',
                    '#MovieMagic', '#FilmArt', '#PosterArt'
                ];
                
                if (concept.genre) {
                    const genreLower = concept.genre.toLowerCase();
                    if (genreLower.includes('horror')) {
                        baseTags.push('#Horror', '#HorrorPoster', '#ScaryMovies', '#HorrorArt');
                    }
                    if (genreLower.includes('sci-fi')) {
                        baseTags.push('#SciFi', '#ScienceFiction', '#Futuristic', '#SciFiArt');
                    }
                }
                
                if (concept.decade) {
                    baseTags.push(`#${concept.decade.replace('s', '')}`);
                    const decadeMap = {
                        '1950s': ['#Vintage', '#Classic', '#RetroStyle'],
                        '1960s': ['#Sixties', '#ModStyle', '#Retro'],
                        '1970s': ['#Seventies', '#VintageStyle', '#RetroAesthetic'],
                        '1980s': ['#Eighties', '#Retro', '#NeonAesthetic', '#Synthwave'],
                        '1990s': ['#Nineties', '#90sAesthetic', '#Nostalgia'],
                        '2000s': ['#Y2K', '#2000sAesthetic', '#Millennium'],
                        '2010s': ['#2010s', '#ModernClassic'],
                        '2020s': ['#Contemporary', '#ModernArt', '#CurrentCinema']
                    };
                    
                    if (decadeMap[concept.decade]) {
                        baseTags.push(...decadeMap[concept.decade]);
                    }
                }
                
                baseTags.push(
                    '#ConceptArt', '#VisualDesign', '#CreativeAI',
                    '#DigitalArt', '#ArtDirection', '#FilmIndustry'
                );
                
                return baseTags.slice(0, 28).sort(() => Math.random() - 0.5).join(' ');
            }

            async copyInstagramCaption() {
                if (!this.elements.instagramCaption.value) return;
                
                try {
                    await navigator.clipboard.writeText(this.elements.instagramCaption.value);
                    
                    const originalText = this.elements.copyCaptionBtn.textContent;
                    this.elements.copyCaptionBtn.textContent = 'Copied! âœ“';
                    this.elements.copyCaptionBtn.classList.add('bg-green-600');
                    this.elements.copyCaptionBtn.classList.remove('bg-pink-600');
                    
                    setTimeout(() => {
                        this.elements.copyCaptionBtn.textContent = originalText;
                        this.elements.copyCaptionBtn.classList.remove('bg-green-600');
                        this.elements.copyCaptionBtn.classList.add('bg-pink-600');
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error copying caption:', error);
                }
            }

            async generateAISongRecommendation(concept) {
                if (!concept.title || !concept.synopsis) {
                    this.elements.songTitle.textContent = '-';
                    this.elements.songArtist.textContent = '-';
                    this.elements.songReason.textContent = '-';
                    this.elements.copySongBtn.disabled = true;
                    return;
                }

                this.elements.songTitle.textContent = 'Generating...';
                this.elements.songArtist.textContent = 'AI is thinking...';
                this.elements.songReason.textContent = 'Analyzing movie themes and finding the perfect soundtrack match...';
                this.elements.copySongBtn.disabled = true;

                try {
                    console.log('Generating AI song recommendation...');
                    
                    const response = await fetch(this.BACKEND_BASE_URL + '/api/generate-song', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ concept })
                    });

                    const responseText = await response.text();

                    if (!response.ok) {
                        throw new Error('Song recommendation request failed: ' + response.status + ' - ' + responseText);
                    }

                    const result = JSON.parse(responseText);
                    
                    if (result.success && result.recommendation) {
                        const rec = result.recommendation;
                        
                        this.elements.songTitle.textContent = rec.title;
                        this.elements.songArtist.textContent = rec.artist + (rec.year ? ' (' + rec.year + ')' : '');
                        this.elements.songReason.textContent = rec.reason;
                        this.elements.copySongBtn.disabled = false;
                        
                        console.log('AI song recommendation generated:', rec);
                    } else {
                        throw new Error(result.error || 'Invalid response from song API');
                    }
                } catch (error) {
                    console.error('Error generating AI song recommendation:', error);
                    console.log('Falling back to static song recommendation...');
                    this.generateFallbackSongRecommendation(concept);
                }
            }

            generateFallbackSongRecommendation(concept) {
                const recommendation = this.getSongForMovie(concept);
                
                this.elements.songTitle.textContent = recommendation.title;
                this.elements.songArtist.textContent = recommendation.artist;
                this.elements.songReason.textContent = recommendation.reason + ' (Generated using fallback system)';
                this.elements.copySongBtn.disabled = false;
            }

            getSongForMovie(concept) {
                const genre = (concept.genre || '').toLowerCase();
                const decade = concept.decade || '';
                const title = concept.title || 'Untitled';
                
                const songDatabase = {
                    '1950s': {
                        horror: { title: 'Monster Mash', artist: 'Bobby Pickett', reason: 'Classic 50s horror novelty song' },
                        'sci-fi': { title: 'Flying Purple People Eater', artist: 'Sheb Wooley', reason: 'Whimsical 50s sci-fi hit' },
                        default: { title: 'Only You', artist: 'The Platters', reason: 'Quintessential 50s romance' }
                    },
                    '1980s': {
                        horror: { title: 'Thriller', artist: 'Michael Jackson', reason: 'The ultimate 80s horror anthem' },
                        'sci-fi': { title: 'Blue Monday', artist: 'New Order', reason: 'Futuristic synth-pop classic' },
                        default: { title: "Don't Stop Believin'", artist: 'Journey', reason: 'Anthemic 80s rock' }
                    },
                    '2020s': {
                        horror: { title: 'bad guy', artist: 'Billie Eilish', reason: 'Dark pop with horror aesthetic' },
                        'sci-fi': { title: 'Blinding Lights', artist: 'The Weeknd', reason: 'Synthwave with futuristic sound' },
                        default: { title: 'drivers license', artist: 'Olivia Rodrigo', reason: 'Emotional storytelling ballad' }
                    }
                };

                const defaultSongs = [
                    { title: 'Bohemian Rhapsody', artist: 'Queen', reason: 'Epic cinematic rock' },
                    { title: 'Hotel California', artist: 'Eagles', reason: 'Dark narrative rock' }
                ];

                let genreCategory = 'default';
                if (genre.includes('horror')) genreCategory = 'horror';
                else if (genre.includes('sci-fi')) genreCategory = 'sci-fi';

                const decadeSongs = songDatabase[decade] || { default: defaultSongs };
                const genreSongs = decadeSongs[genreCategory] || decadeSongs['default'] || defaultSongs;

                const selectedSong = genreSongs[Math.floor(Math.random() * genreSongs.length)];

                return {
                    title: selectedSong.title,
                    artist: selectedSong.artist,
                    reason: selectedSong.reason + ' - Perfect for "' + title + '"'
                };
            }

            async copySongInfo() {
                if (!this.elements.songTitle.textContent || this.elements.songTitle.textContent === '-') return;
                
                const songInfo = 'ðŸŽµ Soundtrack Recommendation:\n"' + this.elements.songTitle.textContent + '" by ' + this.elements.songArtist.textContent + '\n\n' + this.elements.songReason.textContent;
                
                try {
                    await navigator.clipboard.writeText(songInfo);
                    
                    const originalText = this.elements.copySongBtn.textContent;
                    this.elements.copySongBtn.textContent = 'Copied! âœ“';
                    this.elements.copySongBtn.classList.add('bg-green-600');
                    this.elements.copySongBtn.classList.remove('bg-indigo-600');
                    
                    setTimeout(() => {
                        this.elements.copySongBtn.textContent = originalText;
                        this.elements.copySongBtn.classList.remove('bg-green-600');
                        this.elements.copySongBtn.classList.add('bg-indigo-600');
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error copying song info:', error);
                }
            }

            showError(message) {
                if (this.elements.errorText) this.elements.errorText.textContent = message;
                if (this.elements.errorMessage) this.elements.errorMessage.classList.remove('hidden');
                this.updateStatus('error', 'Error occurred');
            }

            hideError() {
                if (this.elements.errorMessage) this.elements.errorMessage.classList.add('hidden');
            }

            clearError() {
                this.hideError();
                this.updateStatus('ready', 'Ready');
            }

            setLoadingState(isLoading) {
                this.isGenerating = isLoading;
                this.elements.generateBtn.disabled = isLoading;
                this.elements.saveBtn.disabled = isLoading || !this.elements.posterImage.src;
                this.elements.shareBtn.disabled = isLoading || !this.elements.posterImage.src;
                
                if (isLoading) {
                    this.elements.loader.classList.remove('hidden');
                    this.elements.posterImage.classList.add('hidden');
                    this.elements.btnText.textContent = 'Generating...';
                    this.updateStatus('generating', 'Generating');
                } else {
                    this.elements.loader.classList.add('hidden');
                    this.elements.posterImage.classList.remove('hidden');
                    this.elements.btnText.textContent = 'Generate New Poster';
                    this.updateStatus('ready', 'Ready');
                    this.elements.saveBtn.disabled = false;
                    this.elements.shareBtn.disabled = false;
                }
            }

            updateStatus(type, text) {
                if (!this.elements.statusIndicator) return;
                
                const indicator = this.elements.statusIndicator.querySelector('div');
                const statusText = this.elements.statusIndicator.querySelector('span');
                
                if (indicator) {
                    indicator.className = 'w-2 h-2 rounded-full mr-2 pulse-ring';
                    
                    switch(type) {
                        case 'ready':
                            indicator.classList.add('bg-green-500');
                            break;
                        case 'generating':
                            indicator.classList.add('bg-blue-500');
                            break;
                        case 'error':
                            indicator.classList.add('bg-red-500');
                            break;
                    }
                }
                
                if (statusText) {
                    statusText.textContent = text;
                }
            }

            updateRecentDisplay() {
                const self = this;
                this.elements.recentPosters.innerHTML = '';
                this.recentPosters.forEach((poster, index) => {
                    const thumb = document.createElement('div');
                    thumb.className = 'aspect-[2/3] bg-gray-700 rounded-lg overflow-hidden cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all';
                    thumb.innerHTML = '<img src="' + poster.imageUrl + '" alt="' + poster.concept.title + '" class="w-full h-full object-cover">';
                    thumb.addEventListener('click', function() {
                        self.loadPosterFromRecent(index);
                    });
                    self.elements.recentPosters.appendChild(thumb);
                });
            }

            loadPosterFromRecent(index) {
                const poster = this.recentPosters[index];
                this.elements.posterImage.src = poster.imageUrl;
                this.currentConcept = poster.concept;
                this.updateInfo(poster.concept);
                this.elements.posterImage.classList.remove('hidden');
                this.elements.loader.classList.add('hidden');
            }

            async savePoster() {
                if (!this.elements.posterImage.src) return;
                
                try {
                    const link = document.createElement('a');
                    const title = this.currentConcept && this.currentConcept.title ? this.currentConcept.title.replace(/\s+/g, '-') : 'generated';
                    link.download = 'movie-poster-' + title + '.png';
                    link.href = this.elements.posterImage.src;
                    link.click();
                } catch (error) {
                    console.error('Error saving poster:', error);
                    this.showError('Failed to save poster. Please try again.');
                }
            }

            async sharePoster() {
                if (!this.currentConcept) return;
                
                try {
                    if (navigator.share) {
                        await navigator.share({
                            title: 'Movie Poster: ' + this.currentConcept.title,
                            text: 'Check out this AI-generated poster: "' + this.currentConcept.title + '" - ' + this.currentConcept.tagline,
                            url: window.location.href
                        });
                    } else {
                        const shareText = 'Check out this AI-generated poster: "' + this.currentConcept.title + '" - ' + this.currentConcept.tagline;
                        await navigator.clipboard.writeText(shareText);
                        
                        const originalText = this.elements.shareBtn.textContent;
                        this.elements.shareBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            this.elements.shareBtn.textContent = originalText;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('Error sharing poster:', error);
                }
            }

            toggleAutoGenerate() {
                this.autoGenerate = !this.autoGenerate;
                const toggle = this.elements.autoToggle;
                const slider = toggle.querySelector('span');
                
                if (this.autoGenerate) {
                    toggle.classList.add('bg-green-600');
                    toggle.classList.remove('bg-gray-600');
                    slider.classList.add('translate-x-6');
                    slider.classList.remove('translate-x-1');
                    this.startAutoTimer();
                } else {
                    toggle.classList.add('bg-gray-600');
                    toggle.classList.remove('bg-green-600');
                    slider.classList.add('translate-x-1');
                    slider.classList.remove('translate-x-6');
                    this.stopAutoTimer();
                }
            }

            startAutoTimer() {
                if (!this.autoGenerate) return;
                
                this.stopAutoTimer();
                let timeLeft = 180; // 3 minutes
                const self = this;
                
                const updateTimer = function() {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    self.elements.autoTimer.textContent = 'Next: ' + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
                    
                    if (timeLeft <= 0) {
                        if (!self.isGenerating && self.autoGenerate) {
                            self.handleGeneration();
                        }
                        self.startAutoTimer();
                    } else {
                        timeLeft--;
                    }
                };
                
                this.autoTimer = setInterval(updateTimer, 1000);
                updateTimer();
            }

            stopAutoTimer() {
                if (this.autoTimer) {
                    clearInterval(this.autoTimer);
                    this.autoTimer = null;
                    this.elements.autoTimer.textContent = 'Next: Manual';
                }
            }

            // MAIN GENERATION FUNCTION - FIXED
            async handleGeneration(retryCount = 0, maxRetries = 2) {
                try {
                    console.log('ðŸŽ¬ Starting poster generation...');
                    this.clearError?.();
                    this.setLoadingState(true);

                    // Step 1: Generate concept
                    const concept = await this.generateMovieConcept();
                    if (!concept) { 
                        this.setLoadingState(false); 
                        return; 
                    }

                    console.log('âœ… Concept generated:', concept.title);
                    this.currentConcept = concept;
                    this.updateInfo?.(concept);

                    // Step 2: Generate base image
                    this.updateProgress('image', 35);
                    const baseImageUrl = await this.generateImage(this.buildVisualIntent(concept), concept);
                    if (!baseImageUrl) {
                        if (retryCount < maxRetries) {
                            console.log(`ðŸ”„ Retrying entire generation process (${retryCount + 1}/${maxRetries})...`);
                            this.setLoadingState(false);
                            setTimeout(() => this.handleGeneration(retryCount + 1, maxRetries), 3000);
                            return;
                        }
                        this.setLoadingState(false);
                        this.showError('Failed to generate image after multiple attempts. Please try again.');
                        return;
                    }

                    console.log('âœ… Base image generated');

                    // Step 3: Load image to canvas
                    this.updateProgress('text', 55);
                    await this.loadImageToCanvas(baseImageUrl);
                    console.log('âœ… Image loaded to canvas');

                    // Step 4: Add overlays and text
                    this.updateProgress('text', 75);
                    this.addGradientOverlays();
                    console.log('âœ… Gradients applied');

                    this.updateProgress('text', 85);
                    this.renderTitleAndCredits(concept);
                    console.log('âœ… Title and credits rendered');

                    this.updateProgress('complete', 100);

                    // Step 5: Display final poster
                    const finalImageUrl = this.elements.canvas.toDataURL('image/png', 1.0);
                    this.elements.posterImage.src = finalImageUrl;
                    
                    console.log('âœ… Final poster URL created, length:', finalImageUrl.length);
                    console.log('âœ… Image src set to poster element');

                    // Update counters and history
                    this.generationCount++;
                    if (this.elements.generationCounter) {
                        const plural = this.generationCount === 1 ? 'poster' : 'posters';
                        this.elements.generationCounter.textContent = `${this.generationCount} ${plural} created`;
                    }

                    if (!this.recentPosters) this.recentPosters = [];
                    this.recentPosters.unshift({ imageUrl: finalImageUrl, concept, timestamp: Date.now() });
                    if (this.recentPosters.length > 12) {
                        this.recentPosters = this.recentPosters.slice(0, 12);
                    }
                    this.updateRecentDisplay?.();

                    console.log('ðŸŽ‰ Poster generation complete!');

                    if (this.autoGenerate) {
                        setTimeout(() => this.startAutoTimer?.(), 1000);
                    }

                } catch (error) {
                    console.error("âŒ Error in poster generation:", error);
                    console.error("Stack trace:", error.stack);

                    if (retryCount < maxRetries && (
                        error.name === 'AbortError' ||
                        error.message.includes('timeout') ||
                        error.message.includes('500'))
                    ) {
                        console.log(`ðŸ”„ Auto-retrying generation (${retryCount + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return this.handleGeneration(retryCount + 1, maxRetries);
                    }

                    this.showError('Failed to generate poster: ' + error.message);
                } finally {
                    this.setLoadingState(false);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing EnhancedPosterAI...');
            window.posterAI = new EnhancedPosterAI();
        });
    </script>
</body>
</html>